/* Two animation methods */
/* 1. The transition property - changes can be made when an event occurs */
/* 2. Using the keyframes @ rule */
/* For performance issues */
/* It's best to animate two properties: transform and opacity. These two properties are what the browsers have been optimised for */
@keyframes moveInFromLeft {
  0% {
    opacity: 0;
    /* Since we want the text to come in from the left, it should reside there before it has to be rendered */
    /* transform: translateX(-100px); */
    transform: translateX(-10rem); }
  80% {
    /* transform: translateX(15px); */
    transform: translateX(1.5rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

@keyframes moveInFromRight {
  0% {
    opacity: 0;
    /* transform: translateX(100px); */
    transform: translateX(10rem); }
  80% {
    /* transform: translateX(-15px); */
    transform: translateX(-1.5rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

@keyframes moveInFromBottom {
  0% {
    opacity: 0;
    /* transform: translateY(70px); */
    transform: translateY(7rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

/* CSS Reset */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit; }

/* Setting the root element font size to a number we can have more control over and enable us use relative  units */
html {
  /* font-size: 10px; */
  /* Therefore, 1rem = 10px */
  font-size: 62.5%; }

/* Using the power of inheritance, we set properties like font in the body */
body {
  box-sizing: border-box; }

body {
  font-family: 'Lato', sans-serif;
  font-weight: 400;
  /* font-size: 16px; */
  line-height: 1.7;
  color: #777;
  /* padding: 30px; */
  padding: 3rem; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  /* To stop the shaky effects noticed during animations */
  backface-visibility: hidden;
  /* margin-bottom: 60px; */
  margin-bottom: 6rem; }
  .heading-primary--main {
    display: block;
    /* font-size: 60px; */
    font-size: 6rem;
    font-weight: 400;
    /* letter-spacing: 35px; */
    letter-spacing: 3.5rem;
    /* To trigger animations, there are twon important properties, animation-name & animation-duration */
    animation-name: moveInFromLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out;
    /* animation-delay: 3s; */
    /* animation-iteration-count: 3; */ }
  .heading-primary--sub {
    display: block;
    /* font-size: 20px; */
    font-size: 2rem;
    font-weight: 700;
    /* letter-spacing: 17.4px; */
    letter-spacing: 1.75rem;
    /* Animations */
    animation: moveInFromRight 1s ease-out; }

.btn:link, .btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  /* padding: 15px 40px; */
  padding: 1.5rem 4rem;
  display: inline-block;
  /* border-radius: 100px; */
  border-radius: 10rem;
  transition: all 0.2s;
  position: relative;
  font-size: 1.6rem; }

.btn:hover {
  /* transform: translateY(-3px); */
  transform: translateY(-0.3rem);
  /* Order of values for box-shadow: offsetX offsetY blur color */
  /* box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2); */
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2); }
  .btn:hover::after {
    transform: scaleX(1.4) scaleY(1.6);
    opacity: 0; }

.btn::active {
  transform: translateY(-1px);
  /* box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2); */
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); }

.btn--white {
  background-color: #fff;
  color: #777; }
  .btn--white::after {
    background-color: #fff; }

.btn::after {
  content: '';
  display: inline-block;
  height: 100%;
  width: 100%;
  border-radius: 100px;
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all 0.4s; }

.btn--animated {
  animation: moveInFromBottom 1s ease-out 0.75s;
  /* This property ensures that the animation properties set in the keyframes at 0% will be applied to the button on pageload */
  animation-fill-mode: backwards; }

.row {
  max-width: 114rem;
  background-color: #eee;
  margin: 0 auto; }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: '';
    display: table;
    clear: both; }
  .row [class^='col-'] {
    background-color: orangered;
    float: left; }
    .row [class^='col-']:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - 2 * 6rem) / 3); }
  .row .col-2-of-3 {
    width: calc( 2 * ((100% - 2 * 6rem) / 3) + 6rem); }
  .row .col-1-of-4 {
    width: calc((100% - 3 * 6rem) / 4); }
  .row .col-2-of-4 {
    width: calc( 2 * ((100% - 3 * 6rem) / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc( 3 * ((100% - 3 * 6rem) / 4) + (2 * 6rem)); }

.header {
  height: 95vh;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  position: relative;
  clip-path: polygon(0 0, 100% 0, 100% 75%, 0 100%); }
  .header__logo-box {
    position: absolute;
    /* top: 40px; */
    top: 4rem;
    /* left: 40px; */
    left: 4rem; }
  .header__logo {
    /* The width would be sorted by the browser */
    /* height: 35px; */
    height: 3.5rem; }
  .header__text-box {
    /* The position, top and left properties are dependent on the parent element */
    position: absolute;
    top: 40%;
    left: 50%;
    /* However, because what we want is to center the text box properly on the page, we use the transform property along with translate, this is totally independent on the parent elements but only on the element's position. */
    transform: translate(-50%, -50%);
    text-align: center; }
